/// <reference types="vite/client" />
// Run from root with `npm run updateStyles`

import fs from 'fs'
import chalk from 'chalk'

// Configruation:
// Data from https://studio.mapbox.com/styles/hejco/cl706a84j003v14o23n2r81w7/edit/#13.49/48.95568/9.13281
const apiUrl = `https://api.mapbox.com/styles/v1/hejco/cl706a84j003v14o23n2r81w7?access_token=${
  import.meta.env.VITE_MAPBOX_STYLE_ACCESS_TOKEN
}`

// Only groups with `atlas_` prefix are used
const mapboxGroupPrefix = 'atlas_'

// Folder
const scriptJsonFolder = 'scripts/MapboxStyles/json'
const componentFolder =
  'src/components/MapInterface/mapData/topicsMapData/mapboxStyles'

// Helper:
const log = (title, object: any = '-') => {
  console.log(
    chalk.inverse.bold(` ${title}${object === '-' ? '' : ':'} `),
    object
  )
}

// Script:
// Script: Fetch rawData
const fetchStyles = await fetch(apiUrl)

if (!fetchStyles.ok) {
  console.error('Fetch failed', fetchStyles)
  process.exit()
}

const rawData = await fetchStyles.json()

// Script: For debugging, write the rawData
fs.writeFileSync(
  `${scriptJsonFolder}/atlas-raw-api-response.json`,
  JSON.stringify(rawData, undefined, 2)
)
log('Received raw data', rawData)

// Script: Remove all non-FMC-groups
type MapBoxGroupEntry = { name: string; collapsed: boolean }
type Group = { key: string; name: string }

const groups = Object.entries(rawData.metadata['mapbox:groups'])
  .map((entry) => {
    const key = entry[0] as string
    const values = entry[1] as MapBoxGroupEntry
    if (values.name.startsWith(mapboxGroupPrefix)) {
      return { key: key, name: values.name }
    }
    return null
  })
  .filter((e): e is Group => !!e) // Learn more https://www.benmvp.com/blog/filtering-undefined-elements-from-array-typescript/

log(`Received ${groups.length} groups`)

// Script: For each group, collect the layers:
// Create our own data
const groupsAndLayers = groups.map((group) => {
  return {
    group: group.name,
    layers: rawData.layers.filter((layer) => {
      return layer.metadata && layer.metadata['mapbox:group'] == group.key
    }),
  }
})

// Cleanup keys from layers that we don't need or that we need to add ourselved later:
groupsAndLayers.forEach((g) =>
  g.layers.forEach((layer) => {
    delete layer.metadata
    delete layer.source
    delete layer['source-layer']
    delete layer?.layout?.visibility // The source styles are sometimes set hidden; we need to reset this
  })
)

// Cleanup layer names
const changedNames: [string, string][] = []
groupsAndLayers.forEach((g) => {
  const name = g.group
  const cleanName = name.toLowerCase().replace(/[^a-z_]/g, '')
  if (name !== cleanName) {
    g.group = cleanName
    changedNames.push([name, cleanName])
  }
})
if (changedNames.length) {
  log(`${changedNames.length} group names where renamed:`, { changedNames })
}

// Write file
const stylesFile = `${componentFolder}/mapbox-layer-styles-by-group.json`
fs.writeFileSync(stylesFile, JSON.stringify(groupsAndLayers, undefined, 2))
log(`Write stylesFile`, stylesFile)

// Script: Generate types file
// (Don't change the new lines and spaces in this template; the generated output does fit Prettier conventions.)
const sortedGroupsAndLayers = groupsAndLayers.sort((a, b) =>
  a.group.localeCompare(b.group)
)
type TypeGroup = [string, string[]]
const typeGroupKeys = Array.from(
  new Set(sortedGroupsAndLayers.map((entry) => entry.group.split('_')[1]))
)
const typeGroups = typeGroupKeys.map((groupKey) => {
  const groupValues = sortedGroupsAndLayers
    .filter((entry) =>
      entry.group.startsWith(`${mapboxGroupPrefix}${groupKey}`)
    )
    .map((entry) => entry.group)
  return [groupKey, groupValues] as TypeGroup
})
// This is the file that we write.
// We create one type with all Ids
// And one Type per Group with only the Ids of that type.
const typesFileContent = `// Autogenerated by \`scripts/MapboxStyles/process.ts\`
// Do not change this file manually

export type MapboxStylesByLayerGroupIds =
${sortedGroupsAndLayers.map((g) => `  | '${g.group}'\n`).join('')}
${typeGroups
  .map((entry) => {
    const [groupKey, groupValues] = entry as TypeGroup
    const typeKeyPart = `${groupKey[0].toUpperCase()}${groupKey.substring(1)}`
    const exportString = `export type MapboxStyleLayerGroup${typeKeyPart}Ids`
    if (groupValues.length > 1) {
      return `${exportString} =\n${groupValues
        .map((g) => `  | '${g}'\n`)
        .join('')}`
    } else {
      return `${exportString} = ${groupValues.map((g) => `'${g}'`).join('')}`
    }
  })
  .join('\n')}
`

fs.writeFileSync(`${componentFolder}/types.ts`, typesFileContent)
log(`Write typesFile`, typesFileContent)

// Script: Write meta data file
const metaFileContent = {
  about: 'Metadata on the last processing of the styles api response',
  processed_at: new Date().toLocaleString('de-DE'),
  style_last_published: {
    published_at: new Date(rawData.modified).toLocaleString('de-DE'),
    version: rawData.version,
  },
  style_id: rawData.id,
  style_owner: rawData.owner,
  style_name: rawData.name,
  debug_changed_names: {
    about: `The folder names in Mapbox need to follow a pattern of \`${mapboxGroupPrefix}[DataIdentifier]_[OptionalStyleIdentifier]\`, otherwise the script will create unexpected results. During processing, we cleanup the names. If any names show up below, those need to be fixed in Mapbox to prevent errors.`,
    changedNames,
  },
}
fs.writeFileSync(
  `${scriptJsonFolder}/metadata_last_process.json`,
  JSON.stringify(metaFileContent, undefined, 2)
)
log(`Store metadata on processing`, metaFileContent)
